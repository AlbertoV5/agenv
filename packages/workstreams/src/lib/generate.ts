/**
 * Workstream generation functions
 *
 * Creates workstream directories with PLAN.md and tasks.json files.
 */

import { existsSync, mkdirSync } from "fs"
import { join } from "path"
import type { StreamMetadata, GeneratedBy, TasksFile } from "./types.ts"
import { VERSION as WORKSTREAMS_VERSION } from "../version.ts"
import { getWorkDir } from "./repo.ts"
import {
  getOrCreateIndex,
  saveIndex,
  getNextOrderNumber,
  formatOrderNumber,
  atomicWriteFile,
} from "./index.ts"
import { toTitleCase, getDateString } from "./utils.ts"

/**
 * Generate the version string for templates
 */
function getVersionString(): string {
  return `@agenv/workstreams@${WORKSTREAMS_VERSION}`
}

export interface GenerateStreamArgs {
  name: string
  repoRoot: string
}

export interface GenerateStreamResult {
  streamId: string
  streamPath: string
}

/**
 * Generate PLAN.md content with the new structured format
 */
function generatePlanMd(
  streamId: string,
  streamName: string,
): string {
  const titleName = toTitleCase(streamName)
  const now = getDateString()
  const version = getVersionString()

  return `# Plan: ${titleName}

> **Stream ID:** ${streamId} | **Created:** ${now} | **Generated by:** ${version}

## Summary

<!-- High-level overview of what this workstream aims to achieve -->

## References

<!-- Source files, reasoning documents, tools used -->

- <!-- Add references here -->

## Stages

### Stage 1: <!-- Stage Name -->

#### Stage Definition

<!-- The "what" - what this stage accomplishes -->

#### Stage Constitution

**Requirements:**

- <!-- List requirements here -->

**Inputs:**

- <!-- List inputs here -->

**Outputs:**

- <!-- List outputs here -->

**Flows:**

- <!-- Describe flows here -->

#### Stage Questions

<!-- Unknowns, research to-dos as [ ] checkboxes -->
- [ ]

#### Stage Threads

##### Thread 1: <!-- Thread Name -->

**Summary:**
<!-- Short description of this parallelizable work unit -->

**Details:**
<!-- Any content - implementation notes, dependencies, goals, code examples, etc. -->

---

*Last updated: ${now}*
`
}

/**
 * Generate empty tasks.json content
 */
function generateTasksJson(streamId: string): TasksFile {
  return {
    version: "1.0.0",
    stream_id: streamId,
    last_updated: new Date().toISOString(),
    tasks: [],
  }
}

/**
 * Main workstream generation function
 *
 * Creates a new workstream with:
 * - PLAN.md at workstream root (structured markdown)
 * - tasks.json at workstream root (empty, populated by add-task)
 * - files/ (flexible space for outputs)
 */
export function generateStream(args: GenerateStreamArgs): GenerateStreamResult {
  const workDir = getWorkDir(args.repoRoot)

  // Ensure workstreams directory exists
  if (!existsSync(workDir)) {
    mkdirSync(workDir, { recursive: true })
  }

  // Get or create index
  const index = getOrCreateIndex(args.repoRoot)

  // Check if workstream with same name already exists
  const existingStream = index.streams.find((s) => s.name === args.name)
  if (existingStream) {
    throw new Error(
      `Workstream with name "${args.name}" already exists (${existingStream.id})`,
    )
  }

  // Generate stream ID
  const order = getNextOrderNumber(index)
  const streamId = `${formatOrderNumber(order)}-${args.name}`
  const streamPath = `docs/work/${streamId}`
  const streamDir = join(workDir, streamId)

  // Create directories
  mkdirSync(streamDir, { recursive: true })
  mkdirSync(join(streamDir, "files"), { recursive: true })

  // Generate PLAN.md
  atomicWriteFile(
    join(streamDir, "PLAN.md"),
    generatePlanMd(streamId, args.name),
  )

  // Generate empty tasks.json
  atomicWriteFile(
    join(streamDir, "tasks.json"),
    JSON.stringify(generateTasksJson(streamId), null, 2),
  )

  // Create stream metadata (without size)
  const now = new Date().toISOString()
  const generatedBy: GeneratedBy = {
    workstreams: WORKSTREAMS_VERSION,
  }

  const streamMetadata: StreamMetadata = {
    id: streamId,
    name: args.name,
    order,
    size: "medium", // Deprecated - will be removed
    session_estimated: {
      length: 4,
      unit: "session",
      session_minutes: [30, 45],
      session_iterations: [4, 8],
    },
    created_at: now,
    updated_at: now,
    path: streamPath,
    generated_by: generatedBy,
  }

  // Update index
  index.streams.push(streamMetadata)
  saveIndex(args.repoRoot, index)

  return {
    streamId,
    streamPath,
  }
}

/**
 * Create generate args (simplified - no size parameters)
 */
export function createGenerateArgs(
  name: string,
  repoRoot: string,
): GenerateStreamArgs {
  return {
    name,
    repoRoot,
  }
}

// ============================================
// DEPRECATED EXPORTS (kept for backwards compatibility during migration)
// These will be removed in Stage 5
// ============================================

/**
 * @deprecated Use generateStream with new args
 */
export interface LegacyGenerateStreamArgs {
  name: string
  size: "short" | "medium" | "long"
  repoRoot: string
  stages: number
  supertasks: number
  subtasks: number
}

/**
 * @deprecated Use generateStream with new args
 */
export interface LegacyGenerateStreamResult {
  streamId: string
  streamPath: string
  size: "short" | "medium" | "long"
  stages: number
  supertasks: number
  subtasks: number
  sessions: number
}
