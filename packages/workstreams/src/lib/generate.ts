/**
 * Workstream generation functions
 *
 * Creates workstream directories with PLAN.md and supporting files.
 */

import { existsSync, mkdirSync, readFileSync } from "fs"
import { join } from "path"
import type { StreamMetadata, GeneratedBy, ConsolidateError } from "./types.ts"
import { VERSION as WORKSTREAMS_VERSION } from "../version.ts"
import { getWorkDir } from "./repo.ts"
import {
  getOrCreateIndex,
  saveIndex,
  getNextOrderNumber,
  formatOrderNumber,
  atomicWriteFile,
} from "./index.ts"
import { toTitleCase, getDateString } from "./utils.ts"
import { parseStreamDocument } from "./stream-parser.ts"

/**
 * Generate the version string for templates
 */
function getVersionString(): string {
  return `@agenv/workstreams@${WORKSTREAMS_VERSION}`
}

export interface GenerateStreamArgs {
  name: string
  repoRoot: string
  stages?: number // Number of stages to generate (default: 1)
}

export interface GenerateStreamResult {
  streamId: string
  streamPath: string
}

/**
 * Generate a single stage template
 */
function generateStageTemplate(stageNum: number): string {
  const paddedNum = stageNum.toString().padStart(2, "0")
  return `### Stage ${paddedNum}: <!-- Stage Name -->

#### Stage Definition

<!-- The "what" - what this stage accomplishes -->

#### Stage Constitution

Describe how this stage operates: what it needs (inputs), how it's organized (structure), and what it produces (outputs).

#### Stage Questions

<!-- Unknowns, research to-dos as [ ] checkboxes -->
- [ ]

#### Stage Batches

##### Batch 01: <!-- Batch Name -->

<!-- What this batch accomplishes -->

###### Thread 01: <!-- Thread Name -->

**Summary:**
<!-- Short description of this parallelizable work unit -->

**Details:**
<!-- Any content - implementation notes, dependencies, goals, code examples, etc. -->`
}

/**
 * Generate PLAN.md content with the new structured format
 */
function generatePlanMd(
  streamId: string,
  streamName: string,
  numStages: number = 1,
): string {
  const titleName = toTitleCase(streamName)
  const now = getDateString()
  const version = getVersionString()

  // Generate stage templates
  const stages: string[] = []
  for (let i = 1; i <= numStages; i++) {
    stages.push(generateStageTemplate(i))
  }

  return `# Plan: ${titleName}

> **Stream ID:** ${streamId} | **Created:** ${now} | **Generated by:** ${version}

## Summary

<!-- High-level overview of what this workstream aims to achieve -->

## References

<!-- Source files, reasoning documents, tools used -->

- <!-- Add references here -->

## Stages

${stages.join("\n\n")}

---

*Last updated: ${now}*
`
}

/**
 * Generate docs/README.md content
 */
function generateDocsReadme(): string {
  return `# Additional Documentation

This directory is for supplementary documentation that doesn't fit within the structured REPORT.md format.

## Purpose

Use this directory for:
- Design documents and architecture diagrams
- Research notes and investigation results
- External API documentation
- Meeting notes and decisions
- Any other documentation that supports the workstream

## Organization

Feel free to organize this directory as needed:
- Create subdirectories for different types of documentation
- Use markdown files for text documentation
- Include diagrams, images, or other assets as needed

## Note

This directory is optional. If your workstream doesn't require additional documentation beyond REPORT.md, you can leave this directory empty or remove it.
`
}

/**
 * Generate REPORT.md template content directly from PLAN.md
 * This is used during stream creation before the stream is indexed
 * Falls back to simple template if PLAN.md can't be parsed (e.g., still a template)
 */
function generateReportMdTemplate(
  streamId: string,
  streamName: string,
  planContent: string,
  numStages: number,
): string {
  const errors: ConsolidateError[] = []
  const planDoc = parseStreamDocument(planContent, errors)

  const lines: string[] = []

  // Header
  lines.push(`# Report: ${toTitleCase(streamName)}`)
  lines.push("")
  lines.push(`> **Stream ID:** ${streamId} | **Reported:** ${getDateString()}`)
  lines.push("")

  // Summary section
  lines.push("## Summary")
  lines.push("<!-- High-level summary of what was achieved -->")
  lines.push("")

  // Accomplishments section
  lines.push("## Accomplishments")
  lines.push("")

  // Add a subsection for each stage
  // If PLAN.md parsed successfully, use actual stage names
  // Otherwise, use placeholder names
  if (planDoc && errors.length === 0 && planDoc.stages.length > 0) {
    for (const stage of planDoc.stages) {
      const stagePrefix = stage.id.toString().padStart(2, "0")
      lines.push(`### Stage ${stagePrefix}: ${stage.name}`)
      lines.push("<!-- What was accomplished in this stage -->")
      lines.push("")
      lines.push("#### Key Changes")
      lines.push("- {description}")
      lines.push("")
    }
  } else {
    // Fallback: generate template stages based on numStages
    for (let i = 1; i <= numStages; i++) {
      const stagePrefix = i.toString().padStart(2, "0")
      lines.push(`### Stage ${stagePrefix}: <!-- Stage Name -->`)
      lines.push("<!-- What was accomplished in this stage -->")
      lines.push("")
      lines.push("#### Key Changes")
      lines.push("- {description}")
      lines.push("")
    }
  }

  // File References section
  lines.push("## File References")
  lines.push("")
  lines.push("| File | Changes |")
  lines.push("|------|---------|")
  lines.push("| `path/to/file.ts` | Description of changes |")
  lines.push("")

  // Issues & Blockers section
  lines.push("## Issues & Blockers")
  lines.push("<!-- Any issues encountered, bugs found, or blockers hit -->")
  lines.push("")

  // Next Steps section
  lines.push("## Next Steps")
  lines.push("<!-- Recommended follow-up work -->")
  lines.push("")

  return lines.join("\n")
}

/**
 * Main workstream generation function
 *
 * Creates a new workstream with:
 * - PLAN.md at workstream root (structured markdown)
 */
export function generateStream(args: GenerateStreamArgs): GenerateStreamResult {
  const workDir = getWorkDir(args.repoRoot)

  // Ensure workstreams directory exists
  if (!existsSync(workDir)) {
    mkdirSync(workDir, { recursive: true })
  }

  // Get or create index
  const index = getOrCreateIndex(args.repoRoot)

  // Check if workstream with same name already exists
  const existingStream = index.streams.find((s) => s.name === args.name)
  if (existingStream) {
    throw new Error(
      `Workstream with name "${args.name}" already exists (${existingStream.id})`,
    )
  }

  // Generate stream ID
  const order = getNextOrderNumber(index)
  const streamId = `${formatOrderNumber(order)}-${args.name}`
  const streamPath = `work/${streamId}`
  const streamDir = join(workDir, streamId)

  // Create stream directory
  mkdirSync(streamDir, { recursive: true })

  // Create docs directory
  const docsDir = join(streamDir, "docs")
  mkdirSync(docsDir, { recursive: true })

  // Generate PLAN.md
  const planContent = generatePlanMd(streamId, args.name, args.stages ?? 1)
  atomicWriteFile(join(streamDir, "PLAN.md"), planContent)

  // Note: REPORT.md is created via 'work report init' when needed
  // Note: docs/ directory is created empty for optional documentation

  // Create stream metadata (without size)
  const now = new Date().toISOString()
  const generatedBy: GeneratedBy = {
    workstreams: WORKSTREAMS_VERSION,
  }

  const streamMetadata: StreamMetadata = {
    id: streamId,
    name: args.name,
    order,
    size: "medium", // Deprecated - will be removed
    session_estimated: {
      length: 4,
      unit: "session",
      session_minutes: [30, 45],
      session_iterations: [4, 8],
    },
    created_at: now,
    updated_at: now,
    path: streamPath,
    generated_by: generatedBy,
  }

  // Update index
  index.streams.push(streamMetadata)
  saveIndex(args.repoRoot, index)

  return {
    streamId,
    streamPath,
  }
}

/**
 * Create generate args
 */
export function createGenerateArgs(
  name: string,
  repoRoot: string,
  stages?: number,
): GenerateStreamArgs {
  return {
    name,
    repoRoot,
    stages,
  }
}
