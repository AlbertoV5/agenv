# Plan: Revision Workflow

> **Stream ID:** 006-revision-workflow | **Created:** 2026-01-22 | **Generated by:** @agenv/workstreams@0.1.0

## Summary

Add a revision workflow that mirrors the initial workstream creation flow. This enables adding new stages mid-execution with the same agent-driven process: agent edits PLAN.md, user approves, agent edits TASKS.md, user approves tasks.

**Core Concept:** Revisions mirror the initial workflow but for adding stages after execution has started.

**Target Flow:**
1. User tells agent they want a revision
2. Agent runs `work revision --name "..."` → adds stage template to PLAN.md
3. Agent edits PLAN.md to fill in stage details
4. User reviews and runs `work approve revision` → generates TASKS.md (existing tasks + new stage placeholders)
5. Agent edits TASKS.md to add task descriptions and assign agents
6. User reviews and runs `work approve tasks` → serializes to tasks.json, generates prompts
7. User runs `work continue`

## References

- Working packages: `./packages/workstreams`
- Key existing modules:
  - `packages/workstreams/src/lib/fix.ts` - `appendFixStage()` for adding stages
  - `packages/workstreams/src/lib/tasks-md.ts` - `generateTasksMdFromPlan()`, `generateTasksMdFromTasks()`
  - `packages/workstreams/src/lib/approval.ts` - Approval flow
  - `packages/workstreams/src/lib/tasks.ts` - `addTasks()` with smart merge
  - `packages/workstreams/src/lib/prompts.ts` - `generateAllPrompts()`
  - `packages/workstreams/src/cli/approve.ts` - Approval CLI

## Stages

### Stage 01: Core Library

#### Stage Definition

Implement the hybrid TASKS.md generation that combines existing tasks (with their status) and new stage placeholders.

#### Stage Constitution

**Inputs:**
- Existing `generateTasksMdFromTasks()` function
- Existing `generateTasksMdFromPlan()` function
- PLAN.md structure via `parseStreamDocument()`

**Structure:**
- Create function that merges existing task output with new stage template
- Detect which stages are "new" by comparing tasks.json stage coverage vs PLAN.md stages

**Outputs:**
- `generateTasksMdForRevision()` function that produces hybrid TASKS.md

#### Stage Questions

- [x] How to detect new stages? → Compare stages in tasks.json vs stages in PLAN.md
- [x] Should we track revision origin on tasks? → Optional, can add `revision?: string` field for traceability but not required for v1

#### Stage Batches

##### Batch 01: Hybrid Generation

###### Thread 01: Revision TASKS.md Generation

**Summary:**
Create function that generates TASKS.md with existing tasks (preserving status) plus new stage placeholders.

**Details:**
- Working packages: `./packages/workstreams`
- Edit `src/lib/tasks-md.ts`
- Add function `generateTasksMdForRevision(streamName, existingTasks, doc, newStageNumbers): string`
- Logic:
  1. Use `generateTasksMdFromTasks()` output for existing stages
  2. For new stages (in `newStageNumbers`), generate empty placeholders like `generateTasksMdFromPlan()` does
  3. Merge into single TASKS.md content
- New stages identified by: stages in PLAN.md that have no tasks in tasks.json

###### Thread 02: New Stage Detection

**Summary:**
Create utility to detect which stages in PLAN.md are new (have no tasks yet).

**Details:**
- Working packages: `./packages/workstreams`
- Add to `src/lib/tasks-md.ts` or create `src/lib/revision.ts`
- Add function `detectNewStages(doc, existingTasks): number[]`
- Logic:
  1. Get all stage IDs from PLAN.md (doc.stages)
  2. Get all stage IDs that have tasks in tasks.json
  3. Return stage IDs that are in PLAN.md but not in tasks.json
- This is used by both `work approve revision` and validation

### Stage 02: CLI Commands

#### Stage Definition

Implement `work revision` command for adding stage templates and extend `work approve` to handle revision approval.

#### Stage Constitution

**Inputs:**
- Core library from Stage 01
- Existing CLI patterns from `src/cli/`
- Existing `appendFixStage()` from fix.ts

**Structure:**
- Create `src/cli/revision.ts` for the revision command
- Extend `src/cli/approve.ts` for `work approve revision`

**Outputs:**
- `work revision --name "..."` command
- `work approve revision` command

#### Stage Questions

- [x] Should `work revision` use "Fix -" prefix? → No, use "Revision -" prefix to distinguish from fix stages
- [x] What validation before `work approve revision`? → Check for open questions in new stages, same as `work approve plan`

#### Stage Batches

##### Batch 01: Revision Command

###### Thread 01: Work Revision CLI

**Summary:**
Implement `work revision --name "..."` command that adds a stage template to PLAN.md.

**Details:**
- Working packages: `./packages/workstreams`
- Create `src/cli/revision.ts`
- Register in `bin/work.ts` SUBCOMMANDS
- Command: `work revision --name <name> [--description <desc>]`
- Behavior:
  1. Parse args, load stream
  2. Call modified `appendFixStage()` or new `appendRevisionStage()` that uses "Revision -" prefix
  3. Output: "Added Stage N: Revision - {name} to PLAN.md"
  4. Output: "Edit PLAN.md to fill in details, then run 'work approve revision'"
- Simpler than `work add stage` - no `--stage` reference needed, just appends new stage

###### Thread 02: Append Revision Stage

**Summary:**
Create or modify stage append function to use "Revision -" prefix instead of "Fix -".

**Details:**
- Working packages: `./packages/workstreams`
- Edit `src/lib/fix.ts` or create new function
- Add `appendRevisionStage(repoRoot, streamId, options): Result`
- Similar to `appendFixStage()` but:
  - Uses "Revision - {name}" instead of "Fix - {name}"
  - Template has clean structure (Definition, Constitution, Questions, Batches)
  - No reference to "target stage" - revisions are independent additions

##### Batch 02: Approve Revision Command

###### Thread 01: Work Approve Revision CLI

**Summary:**
Extend approve command to handle `work approve revision`.

**Details:**
- Working packages: `./packages/workstreams`
- Edit `src/cli/approve.ts`
- Add handling for `work approve revision` subcommand
- Behavior:
  1. Detect new stages using `detectNewStages()`
  2. If no new stages found, error: "No new stages to approve"
  3. Validate new stages (check for open questions)
  4. Generate TASKS.md using `generateTasksMdForRevision()`
  5. Write TASKS.md to stream directory
  6. Output: "Generated TASKS.md with N existing tasks and M new task placeholders"
  7. Output: "Edit TASKS.md to add task details and assign agents, then run 'work approve tasks'"
- Does NOT modify approval status - that happens when `work approve tasks` runs

### Stage 03: Skill Update & Tests

#### Stage Definition

Update the planning-workstreams skill to document the revision workflow and add tests.

#### Stage Constitution

**Inputs:**
- Completed implementation from Stages 01-02
- Current skill documentation

**Structure:**
- Add revision workflow section to skill
- Add tests for new functions

**Outputs:**
- Updated skill documentation
- Test coverage

#### Stage Questions

- [x] Where in skill should revision docs go? → New "Revision Workflow" section in workflow overview + CLI reference

#### Stage Batches

##### Batch 01: Documentation and Tests

###### Thread 01: Skill Documentation

**Summary:**
Update planning-workstreams skill with revision workflow documentation.

**Details:**
- Working packages: `./skills/planning-workstreams`
- Edit `SKILL.md`
- Add "Revision Workflow" section explaining:
  - When to use (adding stages after execution started)
  - Full flow with commands
  - How it mirrors initial workflow
- Update CLI Reference with:
  - `work revision --name "..."`
  - `work approve revision`
- Add example showing the revision flow

###### Thread 02: Tests

**Summary:**
Create tests for revision workflow functions.

**Details:**
- Working packages: `./packages/workstreams`
- Create `tests/revision.test.ts`
- Test cases:
  - `detectNewStages()` correctly identifies stages without tasks
  - `generateTasksMdForRevision()` produces correct hybrid output
  - `appendRevisionStage()` adds stage with correct format
  - CLI argument parsing for `work revision`
  - Full integration: revision → approve revision → approve tasks
- Use temp directory pattern from existing tests

### Stage 04: Revision - TASKS.md cleanup

#### Stage Definition

Investigate and fix the issue where TASKS.md is not being deleted after `work approve tasks` runs successfully. The deletion code exists in `approve.ts` but TASKS.md persists after task approval.

#### Stage Constitution

**Inputs:**
- Current `deleteTasksMd()` function in `src/cli/approve.ts`
- Current `handleTasksApproval()` flow

**Structure:**
- Investigate why deletion fails silently
- Fix the deletion logic or error handling

**Outputs:**
- TASKS.md properly deleted after successful task approval

#### Stage Questions

- [x] Where is deletion called? → Line 792 in `handleTasksApproval()` after `approveTasks()`
- [x] Does the function exist? → Yes, `deleteTasksMd()` at line 702
- [x] Why does it fail silently? → Needs investigation (task objective)

#### Stage Batches

##### Batch 01: Investigation and Fix

###### Thread 01: Debug TASKS.md Deletion

**Summary:**
Investigate why `deleteTasksMd()` fails to remove TASKS.md and fix the issue.

**Details:**
- Working packages: `./packages/workstreams`
- The `deleteTasksMd()` function at line 702 catches all errors silently
- Check if the function is actually being called
- Check if there's a path mismatch or permission issue
- Add logging or fix error handling to surface the actual issue
- Verify fix by running `work approve tasks` and confirming TASKS.md is deleted

---

*Last updated: 2026-01-22*
