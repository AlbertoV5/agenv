# Plan: Web Visualization

> **Stream ID:** 000-web-visualization | **Created:** 2026-01-20 | **Generated by:** @agenv/workstreams@0.1.0

## Summary

Add a read-only web visualization interface to the workstreams package. This creates a `work serve` CLI command that starts a local HTTP server using Bun's native `Bun.serve()` to provide a dashboard for viewing workstream progress. The visualization is purely read-only - no mutations or form submissions.

## References

- Package: `packages/workstreams/`
- CLI router: `bin/work.ts`
- Type definitions: `src/lib/types.ts`
- Index operations: `src/lib/index.ts`
- Task operations: `src/lib/tasks.ts`
- Status computation: `src/lib/status.ts`
- Metrics: `src/lib/metrics.ts`
- Stream parser: `src/lib/stream-parser.ts`

## Stages

### Stage 01: Foundation

#### Stage Definition

Set up the core web server infrastructure including the HTTP server, URL router, and data fetching layer that bridges existing lib/* functions to the web views.

#### Stage Constitution

**Inputs:**
- Existing `bin/work.ts` CLI router structure
- Bun's native `Bun.serve()` API
- Existing lib functions: `loadIndex()`, `getTasks()`, `getStreamProgress()`, `evaluateStream()`

**Structure:**
- `src/web/server.ts` - HTTP server wrapper with config
- `src/web/router.ts` - Pattern-based URL routing
- `src/web/data.ts` - Data adapter layer for templates
- `src/cli/serve.ts` - CLI command handler

**Outputs:**
- Running `work serve` starts a web server on localhost:3000
- Server responds to routes with placeholder content
- CLI supports `--port`, `--host` options

#### Stage Questions

- [x] Use Bun native server vs Express/Hono? Decided: Bun native (`Bun.serve()`)
- [x] Template engine? Decided: Tagged template literals (no external deps)
- [x] CSS approach? Decided: Inline styles in template literal

#### Stage Batches

##### Batch 01: Core Server Infrastructure

These threads can run in parallel - they are independent modules.

###### Thread 01: Server Module

**Summary:**
Create `src/web/server.ts` with `Bun.serve()` wrapper.

**Details:**
- Create server configuration interface with port, hostname, repoRoot
- Implement `startServer(config)` function returning `{ stop: () => void }`
- Default port 3000, hostname localhost
- Integrate with router for request handling
- Add graceful shutdown handling
- Error boundaries returning 500 error page

###### Thread 02: Router Module

**Summary:**
Create `src/web/router.ts` with regex-based URL pattern matching.

**Details:**
- Define `RouteHandler` type: `(params: Record<string, string>, repoRoot: string) => Response`
- Define `Route` interface with method, pattern (RegExp), paramNames, handler
- Implement route registration and matching
- Support path parameters like `/stream/:id`
- Routes to define:
  - `GET /` - Dashboard
  - `GET /stream/:id` - Stream detail
  - `GET /api/streams` - JSON API
  - `GET /api/stream/:id` - JSON API single stream
- Return 404 for unmatched routes

###### Thread 03: Data Layer

**Summary:**
Create `src/web/data.ts` as adapter between lib functions and web views.

**Details:**
- Import and use existing lib functions (no duplication of business logic)
- Define `DashboardData` interface with streams, totalTasks, completedTasks
- Define `StreamDetailData` interface with stream, progress, metrics, stages
- Implement `getDashboardData(repoRoot)` - aggregates all streams
- Implement `getStreamDetailData(repoRoot, streamId)` - single stream with full details
- Handle errors gracefully (return null for missing streams)

##### Batch 02: CLI Integration

###### Thread 01: Serve Command

**Summary:**
Create `src/cli/serve.ts` CLI command and register in `bin/work.ts`.

**Details:**
- Follow existing CLI patterns from `src/cli/status.ts`
- Define `ServeCliArgs` interface with repoRoot, port, host, open
- Implement argument parsing for `--port`, `--host`, `--open`, `--repo-root`
- Print server URL on startup
- Add to `bin/work.ts` SUBCOMMANDS object
- Update `printHelp()` with serve command description

### Stage 02: Templates

#### Stage Definition

Create the HTML template system using tagged template literals and implement the dashboard and stream detail views with consistent styling.

#### Stage Constitution

**Inputs:**
- Data layer from Stage 01 providing structured view data
- Existing CLI output patterns for consistency (status colors, progress format)

**Structure:**
- `src/web/templates/layout.ts` - Base HTML wrapper
- `src/web/templates/styles.ts` - CSS styles as template literal
- `src/web/templates/components.ts` - Reusable HTML components
- `src/web/templates/dashboard.ts` - Dashboard view
- `src/web/templates/stream.ts` - Stream detail view

**Outputs:**
- Full HTML pages with styled workstream data
- Consistent visual design matching CLI conventions
- XSS-safe HTML output via template escaping

#### Stage Questions

- [x] Use separate CSS file or inline? Decided: Inline in `<style>` tag
- [x] Color scheme? Decided: Match CLI status colors (green=completed, blue=in_progress, etc.)

#### Stage Batches

##### Batch 01: Base Templates

These threads can run in parallel - independent template modules.

###### Thread 01: Layout and HTML Helper

**Summary:**
Create `src/web/templates/layout.ts` with base HTML structure and template utilities.

**Details:**
- Implement `html` tagged template literal with value escaping for XSS prevention
- Implement `layout(title, content)` function returning complete HTML document
- Include meta viewport for responsive design
- Header with "Workstreams" title linking to dashboard
- Footer with "Read-only view" note
- Integrate styles from styles.ts

###### Thread 02: CSS Styles

**Summary:**
Create `src/web/templates/styles.ts` with CSS as template literal.

**Details:**
- Define CSS custom properties for status colors:
  - `--color-pending: #6b7280` (gray)
  - `--color-in-progress: #3b82f6` (blue)
  - `--color-completed: #22c55e` (green)
  - `--color-blocked: #ef4444` (red)
  - `--color-cancelled: #9ca3af` (light gray)
- Base styles: system-ui font, max-width 1200px, centered
- Progress bar styles matching CLI visual output
- Status badge styles with color coding
- Task list styles with border separators
- Card/section styles with border and padding
- Responsive grid for dashboard stream cards

###### Thread 03: Reusable Components

**Summary:**
Create `src/web/templates/components.ts` with shared HTML components.

**Details:**
- `progressBar(percent, width?)` - visual progress bar (match CLI `formatProgress`)
- `statusBadge(status)` - colored badge for task/stream status
- `taskList(tasks)` - list of tasks with status indicators
- `stageCard(stage)` - card showing stage with batches/threads summary
- `metricsTable(metrics)` - table of evaluation metrics
- `streamCard(stream)` - card for dashboard showing stream summary

##### Batch 02: View Templates

These threads can run in parallel - independent view modules.

###### Thread 01: Dashboard View

**Summary:**
Create `src/web/templates/dashboard.ts` for the all-workstreams listing.

**Details:**
- Accept `DashboardData` from data layer
- Show overall metrics summary (total tasks, completion rate)
- Display streams in responsive grid using `streamCard` component
- Each stream card shows: name, status, progress bar, task counts
- Link each card to `/stream/:id` detail view
- Handle empty state (no workstreams)

###### Thread 02: Stream Detail View

**Summary:**
Create `src/web/templates/stream.ts` for individual workstream view.

**Details:**
- Accept `StreamDetailData` from data layer
- Show stream name, status badge, overall progress
- Display metrics summary table
- List stages with `stageCard` component
- Within each stage card: show batches and threads
- Within each thread: show task list with status
- Highlight blocked tasks if any
- Back link to dashboard

###### Thread 03: Error Pages

**Summary:**
Create error page templates for 404 and 500 responses.

**Details:**
- Create `notFound(path)` template for 404 errors
- Create `serverError(message?)` template for 500 errors
- Use layout wrapper for consistent styling
- Include link back to dashboard
- Keep error messages user-friendly

### Stage 03: Testing and Polish

#### Stage Definition

Add tests for the web server and templates, implement JSON API endpoints, and ensure robust error handling throughout.

#### Stage Constitution

**Inputs:**
- Working server and templates from Stage 01-02
- Existing test patterns from `packages/workstreams/tests/`

**Structure:**
- `tests/web/server.test.ts` - Server and routing tests
- `tests/web/templates.test.ts` - Template rendering tests

**Outputs:**
- Comprehensive test coverage for web functionality
- Working JSON API endpoints
- Production-ready error handling

#### Stage Questions

- [x] Test framework? Decided: Bun's built-in test runner (`bun:test`)

#### Stage Batches

##### Batch 01: JSON API

###### Thread 01: API Endpoints

**Summary:**
Implement JSON API endpoints for programmatic access.

**Details:**
- `GET /api/streams` - Return all streams as JSON array
- `GET /api/stream/:id` - Return single stream detail as JSON
- Set `Content-Type: application/json` header
- Return proper HTTP status codes (200, 404, 500)
- JSON error responses for error cases
- Use data layer functions, serialize to JSON

##### Batch 02: Testing

###### Thread 01: Server Tests

**Summary:**
Create `tests/web/server.test.ts` for server and routing.

**Details:**
- Test route matching logic
- Test path parameter extraction
- Test 404 handling for unknown routes
- Test server start/stop lifecycle
- Test response headers and status codes
- Use `bun:test` framework matching existing tests

###### Thread 02: Template Tests

**Summary:**
Create `tests/web/templates.test.ts` for HTML generation.

**Details:**
- Test HTML escaping for XSS prevention
- Test layout wrapper structure
- Test component functions with sample data
- Test dashboard view with mock DashboardData
- Test stream view with mock StreamDetailData
- Verify HTML structure contains expected elements

---

*Last updated: 2026-01-20*
