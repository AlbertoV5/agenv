# Plan: Workstream Roles

> **Stream ID:** 008-workstream-roles | **Created:** 2026-01-23 | **Generated by:** @agenv/workstreams@0.1.0

## Summary

Implement a role-based access control (RBAC) system for the workstreams CLI that distinguishes between USER and AGENT roles. The role is determined by the `WORKSTREAM_ROLE` environment variable, defaulting to "AGENT" when not set. This system will:

1. Define a configurable role permissions registry that maps roles to allowed commands
2. Enforce permissions at command execution time with clear error messages
3. Dynamically filter CLI help output based on the current role
4. Update documentation to reflect role-based behavior

The goal is to prevent agents from running user-specific commands like `work approve`, `work start`, and `work complete`, while keeping the system flexible enough to modify permissions easily.

## References

- Working package: `./packages/workstreams`
- CLI entry point: `packages/workstreams/bin/work.ts`
- CLI commands: `packages/workstreams/src/cli/*.ts`
- Type definitions: `packages/workstreams/src/lib/types.ts`
- Existing config patterns: `packages/workstreams/src/lib/github/types.ts`

## Stages

### Stage 01: Core Role Infrastructure

#### Stage Definition

Build the foundational role system including type definitions, configuration registry, environment variable handling, and permission checking utilities.

#### Stage Constitution

**Inputs:**
- Existing type definitions in `packages/workstreams/src/lib/types.ts`
- Existing configuration patterns from GitHub config
- List of commands that should be USER-only

**Structure:**
- Create a new `src/lib/roles.ts` module for all role-related logic
- Define role types, permission registry, and utility functions
- Keep the registry as a single source of truth for command permissions

**Outputs:**
- `WorkstreamRole` type enum (USER, AGENT)
- `RolePermissions` configuration interface
- `COMMAND_PERMISSIONS` registry object mapping commands to allowed roles
- `getCurrentRole()` - reads WORKSTREAM_ROLE env var
- `canExecuteCommand(role, command)` - permission check utility
- `getRoleErrorMessage(command)` - formatted denial message

#### Stage Questions

- [x] What should be the default role when WORKSTREAM_ROLE is not set? **AGENT** (agents are the primary CLI users)
- [x] Which commands are USER-only? `approve`, `start`, `complete` only (keep `revoke` and `fix` available to all roles for now)
- [x] Should we support custom roles beyond USER/AGENT in the future? **Yes**, design the registry to be extensible

#### Stage Batches

##### Batch 01: Role System Foundation

Build the complete role infrastructure in a single coordinated effort.

###### Thread 01: Core Role System

**Summary:**
Create the role type definitions, command permissions registry, and enforcement utilities.

**Details:**
- Working package: `./packages/workstreams`
- Create `src/lib/roles.ts` with:
  ```typescript
  export type WorkstreamRole = "USER" | "AGENT"
  
  export interface CommandPermission {
    allowedRoles: WorkstreamRole[]
    denialMessage?: string  // Custom message for this command
  }
  
  export const COMMAND_PERMISSIONS: Record<string, CommandPermission> = {
    // USER-only commands (approval gates)
    "approve": { allowedRoles: ["USER"], denialMessage: "Approval commands require USER role to maintain human-in-the-loop control" },
    "start": { allowedRoles: ["USER"], denialMessage: "Starting workstreams requires USER role" },
    "complete": { allowedRoles: ["USER"], denialMessage: "Completing workstreams requires USER role" },
    
    // All other commands default to both roles
    // ... populate with all commands
  }

  export function getCurrentRole(): WorkstreamRole {
    const envRole = process.env.WORKSTREAM_ROLE?.toUpperCase()
    if (envRole === "USER") return "USER"
    return "AGENT"  // Default to AGENT (primary CLI users)
  }
  
  export function canExecuteCommand(command: string): boolean {
    const permission = COMMAND_PERMISSIONS[command]
    if (!permission) return true  // Unknown commands allowed by default
    return permission.allowedRoles.includes(getCurrentRole())
  }
  
  export function getRoleDenialMessage(command: string): string {
    const role = getCurrentRole()
    const permission = COMMAND_PERMISSIONS[command]
    const baseMessage = permission?.denialMessage || `This command is not available for ${role} role`
    return `Access denied: ${baseMessage}\n\nCurrent role: ${role}\nTo change role, set WORKSTREAM_ROLE environment variable.`
  }
  ```
- Export types and functions for external use
- Write unit tests for role detection and permission checking

### Stage 02: CLI Integration

#### Stage Definition

Integrate the role system into the CLI by adding permission checks to the main router and updating individual commands to respect roles.

#### Stage Constitution

**Inputs:**
- Role infrastructure from Stage 01
- Existing CLI router in `packages/workstreams/bin/work.ts`
- Individual CLI command files in `packages/workstreams/src/cli/*.ts`

**Structure:**
- Add permission check at router level for early rejection
- Update each USER-only command to include role check
- Modify help text generation to be role-aware

**Outputs:**
- Updated `bin/work.ts` with role-based command filtering
- Updated `approve.ts`, `start.ts`, `complete.ts` with role checks
- Role-aware help output throughout the CLI

#### Stage Questions

- [x] Should we check permissions at router level or command level? **Both** - router for early exit, command for detailed errors
- [x] How should help text change for agents? Show only available commands, note that some commands are USER-only

#### Stage Batches

##### Batch 01: Router and Command Updates

Update the main router and the primary USER-only commands with both logic and help text updates.

###### Thread 01: Router and Help Integration

**Summary:**
Modify the main CLI router to check permissions and generate role-aware help.

**Details:**
- Working package: `./packages/workstreams`
- Create `src/lib/help.ts` with:
  ```typescript
  export function getRoleHelpNote(command: string): string | null {
    const permission = COMMAND_PERMISSIONS[command]
    if (permission?.allowedRoles.length === 1 && permission.allowedRoles[0] === "USER") {
      return "Note: This command requires USER role (human-in-the-loop)"
    }
    return null
  }
  
  export function filterCommandsForRole(commands: string[]): string[] {
    const role = getCurrentRole()
    return commands.filter(cmd => canExecuteCommand(cmd))
  }
  ```
- Update `bin/work.ts`:
  - Import role utilities and help utilities
  - Before dispatching to subcommand, check `canExecuteCommand(subcommand)`
  - If denied, print `getRoleDenialMessage(subcommand)` and exit with code 1
  - Update main help to use `filterCommandsForRole()`
  - Add footer to help showing current role
  - Add `--show-all-commands` flag

###### Thread 02: Approve Command

**Summary:**
Update the `approve` command with role enforcement and role-aware help.

**Details:**
- Working package: `./packages/workstreams`
- Update `src/cli/approve.ts`:
  - Add secondary role check at command entry for detailed error
  - Update `printHelp()` to include role requirement note using `getRoleHelpNote` or hardcoded text
  - Add test for role enforcement

###### Thread 03: Start and Complete Commands

**Summary:**
Update `start` and `complete` commands with role enforcement and role-aware help.

**Details:**
- Working package: `./packages/workstreams`
- Update `src/cli/start.ts`:
  - Add role check at entry
  - Update help text with role note
- Update `src/cli/complete.ts`:
  - Add role check at entry
  - Update help text with role note
- Add tests for both commands

### Stage 03: Testing and Documentation

#### Stage Definition

Comprehensive testing of the role system and documentation updates to explain the feature.

#### Stage Constitution

**Inputs:**
- Completed role infrastructure
- Integrated CLI commands
- Existing test patterns in `packages/workstreams/tests`

**Structure:**
- Add unit tests for role module
- Add integration tests for CLI behavior
- Update any existing documentation

**Outputs:**
- Test suite for roles
- Updated CLI documentation

#### Stage Questions

- [x] Where should tests go? `packages/workstreams/tests/roles.test.ts`
- [x] Should we add environment variable documentation? Yes, in relevant help text and any README

#### Stage Batches

##### Batch 01: Testing and Polish

###### Thread 01: Role System Tests

**Summary:**
Write comprehensive tests for the role system.

**Details:**
- Working package: `./packages/workstreams`
- Create `tests/roles.test.ts` with tests for:
  - `getCurrentRole()` with various env values
  - `canExecuteCommand()` for USER-only and shared commands
  - `getRoleDenialMessage()` formatting
  - Command permissions registry completeness
- Create `tests/cli-roles.test.ts` for CLI integration tests:
  - Test that approve/start/complete reject when WORKSTREAM_ROLE=AGENT or unset (default)
  - Test that they succeed when WORKSTREAM_ROLE=USER
  - Test help output filtering

###### Thread 02: Documentation Updates

**Summary:**
Update documentation to explain the role system.

**Details:**
- Working package: `./packages/workstreams`
- Add role documentation section to any existing docs
- Update CLI help descriptions as needed
- Ensure error messages are clear and actionable
- Add inline code comments explaining the role system design

---

*Last updated: 2026-01-23*

### Stage 04: Revision - Agent-Friendly Error Messages

#### Stage Definition

Update error messages for role-restricted commands to be agent-friendly. When an agent tries to run a USER-only command, the error message should instruct the agent to ask the user for help, NOT explain how to change the role (which would be counterproductive).

#### Stage Constitution

**Inputs:**
- Role system from Stage 01 (`packages/workstreams/src/lib/roles.ts`)
- `getRoleDenialMessage()` function that generates error messages

**Structure:**
- Modify denial messages to guide agents toward asking the user
- Remove any mention of `WORKSTREAM_ROLE` environment variable from agent-facing errors
- Keep technical details for USER role errors (when a user somehow gets denied)

**Outputs:**
- Updated `getRoleDenialMessage()` with agent-appropriate messaging
- Error messages that say "ask the user to run X" instead of "set WORKSTREAM_ROLE=USER"

#### Stage Questions

- [x] What should the agent error message say? "This command requires human approval. Ask the user to run `work <command>`"
- [x] Should we differentiate messages based on role? Yes - agents get "ask the user" message, users get technical details

#### Stage Batches

##### Batch 01: Error Message Updates

###### Thread 01: Agent-Friendly Denial Messages

**Summary:**
Update the role denial message generation to produce agent-appropriate error messages that direct agents to ask users for help.

**Details:**
- Working package: `./packages/workstreams`
- Update `getRoleDenialMessage()` in `src/lib/roles.ts`:
  - For AGENT role: "Access denied: This command requires human approval. Please ask the user to run `work <command>` to proceed."
  - Do NOT mention WORKSTREAM_ROLE or how to change roles
  - Keep the message actionable - tell the agent exactly what to ask for
- Update `COMMAND_PERMISSIONS` denial messages to be agent-friendly:
  - `approve`: "Approval requires human oversight. Ask the user to run `work approve <target>`"
  - `start`: "Starting a workstream requires human approval. Ask the user to run `work start`"
  - `complete`: "Completing a workstream requires human approval. Ask the user to run `work complete`"
- Add tests to verify error messages don't leak role-changing instructions
